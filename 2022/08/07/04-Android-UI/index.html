<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="JCC"><title>04-Android-UI · Jiancong Cui</title><meta name="description" content="控件基础知识
宽度高度的取值

match_parent: 由父布局来决定当前控件的大小
wrap_content: 由控件内容决定当前控件的大小
固定值: 单位一般用 dp(一种屏幕密度无关的尺寸单位, 可以保证在不同分辨率的手机上显示效果尽可能地一致)

可见性的取值

visible: 可见
"><meta name="keywords" content="Computer Science, Privacy Security,"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&amp;display=swap"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/tag.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="shortcut icon" href="/images/jcc.webp"><script src="/js/jquery.js"></script><!-- 主题：可换 one-dark/tomorrow/github 等 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css">
<!-- 行号 + 工具栏的样式 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.css">
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/show-language/prism-show-language.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="page-top animated fadeInDown"><div class="nav-container"> <div class="nav"><a class="nav-item logo" href="/">Jiancong Cui </a><a class="nav-item" href="/">About Me</a><a class="nav-item" href="/blogs">Posts</a><a class="nav-item" href="/archives">Archive</a><a class="nav-item" href="/tags">Tags</a><a class="nav-item" href="/quotes">Quotes</a></div></div></div><div id="main-container"><div class="main-content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><a>04-Android-UI</a></div><div class="post-labels"><div class="label-item"> <i class="fa fa-clock-o"></i><span class="date">2022-08-07</span></div><div class="label-item"> <i class="fa fa-list"></i><a class="tag" href="/categories/Android-Dev/" title="Android Dev.">Android Dev.</a></div><div class="label-item"><i class="fa fa-bookmark"></i><a class="tag" href="/tags/Android/" title="Android">Android</a></div><span class="leancloud_visitors"></span></div><div class="post-content"><h1>控件基础知识</h1>
<h2 id="宽度高度的取值">宽度高度的取值</h2>
<ol>
<li><code>match_parent</code>: 由父布局来决定当前控件的大小</li>
<li><code>wrap_content</code>: 由控件内容决定当前控件的大小</li>
<li>固定值: 单位一般用 dp(一种屏幕密度无关的尺寸单位, 可以保证在不同分辨率的手机上显示效果尽可能地一致)</li>
</ol>
<h2 id="可见性的取值">可见性的取值</h2>
<ol>
<li><code>visible</code>: 可见</li>
<li><code>invisible</code>: 不可见, 但是仍然占据着原来的位置和大小</li>
<li><code>gone</code>: 不可见, 且不再占用任何屏幕空间</li>
</ol>
<h1>基础控件</h1>
<h2 id="Button">Button</h2>
<ul>
<li>按钮中字母大写: <code>:textAllCaps: &quot;true&quot;</code></li>
</ul>
<h3 id="事件">事件</h3>
<ul>
<li><code>setOnClickListener</code>: 单击事件</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">button1.setOnClickListener &#123;
    Toast.makeText(this, &quot;You click Button 1&quot;, Toast.LENGTH_SHORT).show()
&#125;</code></pre>
<h3 id="事件的统一处理接口">事件的统一处理接口</h3>
<p>将 Button 的点击事件统一交给 Activity 处理</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class MainActivity : AppCompatActivity(), View.OnClickListener &#123;
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val button_1 &#x3D; findViewById&lt;Button&gt;(R.id.button_1)
        val button_2 &#x3D; findViewById&lt;Button&gt;(R.id.button_2)
        button_1.setOnClickListener(this)
        button_2.setOnClickListener(this)
    &#125;

    override fun onClick(view: View?) &#123;
        Log.d(&quot;TEMP&quot;, (view &#x3D;&#x3D; null).toString())
        when (view?.id) &#123;
            R.id.button_1 -&gt; &#123;
                Toast.makeText(this, &quot;Button 1&quot;, Toast.LENGTH_SHORT).show()
            &#125;
            R.id.button_2 -&gt; &#123;
                Toast.makeText(this, &quot;Button 2&quot;, Toast.LENGTH_SHORT).show()
            &#125;
            else -&gt; &#123;
                Toast.makeText(this, &quot;Button None&quot;, Toast.LENGTH_SHORT).show()
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="TextView">TextView</h2>
<ul>
<li>文字对齐方式: <code>:gravity</code>, 取值有(<code>top, bottom, start, end, center</code>); 使用 <code>|</code> 同时指定多个值</li>
<li>文字颜色: <code>:textColor=&quot;#00ff00&quot;</code></li>
<li>文字大小: <code>:textSize=&quot;24sp&quot;</code> 使用 sp 作为单位，这样当用户在系统中修改了文字显示尺寸时，应用程序中的文字大小也会跟着变化</li>
</ul>
<h2 id="Toast">Toast</h2>
<p>在窗口中进行提示 <code>Toast.makeText(Context, Content, Time)</code>:</p>
<ul>
<li>Context：Toast 要求的上下文，由于 Activity 本身就是一个 Context 对象，因此通常为 this</li>
<li>Content: 显示的文本内容</li>
<li>Time: 显示的时长，有两个内置常量可以选择：<code>Toast.LENGTH_SHORT</code> 和 <code>Toast.LENGTH_LONG</code></li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">Toast.makeText(this, &quot;You click Button 1&quot;, Toast.LENGTH_SHORT).show()</code></pre>
<h2 id="Menu">Menu</h2>
<ol>
<li>新建 menu 资源: <code>res/menu</code> + <code>res/menu/Menu_Resource_File_Name</code></li>
<li>在 <code>Menu_Resource_File_Name</code> 进行资源的添加: `<item/></li>
</ol>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;
    &lt;item
        android:id&#x3D;&quot;@+id&#x2F;add_item&quot;
        android:title&#x3D;&quot;Add&quot;&#x2F;&gt;
    &lt;item
        android:id&#x3D;&quot;@+id&#x2F;remove_item&quot;
        android:title&#x3D;&quot;Remove&quot;&#x2F;&gt;
&lt;&#x2F;menu&gt;</code></pre>
<ol start="3">
<li>重写 Activity 中的 <code>onCreateOptionsMenu()</code> 方法
<ul>
<li>传入的 menu 指向的是当前 Activity 的菜单对象实例</li>
<li><code>menuInflater</code> 实际上调用了父类中的 <code>getMenuInflater()</code> 方法获取到 <code>MenuInflater</code> 对象</li>
<li>然后调用 <code>inflate()</code> 方法给当前 Activity 创建菜单: 第一个参数为菜单资源，第二个参数为菜单上下文</li>
<li>返回 true 表示菜单创建后显示出来</li>
</ul>
</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;
    menuInflater.inflate(R.menu.main, menu)
    return true
&#125;</code></pre>
<h3 id="响应事件">响应事件</h3>
<ul>
<li>菜单项被点击: <code>onOptionsItemSelected()</code></li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 菜单响应事件
override fun onOptionsItemSelected(item: MenuItem): Boolean &#123;
    when (item.itemId) &#123;
        R.id.add_item -&gt; Toast.makeText(this, &quot;You clicked Add&quot;, Toast.LENGTH_SHORT).show()
        R.id.remove_item -&gt; Toast.makeText(this, &quot;You clicked Remove&quot;, Toast.LENGTH_SHORT).show()
    &#125;
    return super.onOptionsItemSelected(item)
&#125;</code></pre>
<h3 id="图标和位置">图标和位置</h3>
<p>在布局文件中通过 icon 属性指定菜单选项的图标, 通过 showAsAction 属性指定菜单选项的展示位置</p>
<ul>
<li>always: 表示永远显示在 Toolbar 中, 空间不够则不显示</li>
<li>ifRoom: 表示优先显示在 Toolbar 中, 空间不够显示在菜单中</li>
<li>never: 表示只显示在菜单中</li>
</ul>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;item
    android:id&#x3D;&quot;@+id&#x2F;backup&quot;
    android:icon&#x3D;&quot;@drawable&#x2F;ic_backup&quot;
    android:title&#x3D;&quot;Backup&quot;
    app:showAsAction&#x3D;&quot;always&quot; &#x2F;&gt;</code></pre>
<h2 id="PopupMenu">PopupMenu</h2>
<p>自定义弹出的 Menu 菜单</p>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202210282053584.png" alt=""></p>
<ol>
<li>准备 Menu 的资源文件</li>
</ol>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;
    &lt;item
        android:id&#x3D;&quot;@+id&#x2F;menu_info_by_day&quot;
        android:icon&#x3D;&quot;@drawable&#x2F;ic_meteor_64&quot;
        android:title&#x3D;&quot;星迹&quot; &#x2F;&gt;
    &lt;item
        android:id&#x3D;&quot;@+id&#x2F;menu_export_db&quot;
        android:icon&#x3D;&quot;@drawable&#x2F;ic_db_export_64&quot;
        android:title&#x3D;&quot;导出数据&quot; &#x2F;&gt;
    &lt;item
        android:id&#x3D;&quot;@+id&#x2F;menu_import_db&quot;
        android:icon&#x3D;&quot;@drawable&#x2F;ic_db_import_64&quot;
        android:title&#x3D;&quot;导入数据&quot; &#x2F;&gt;
&lt;&#x2F;menu&gt;</code></pre>
<ol start="2">
<li>初始化: 初始化时指定其弹出的位置（通过一个 view 对象指定）如果空间足够，它会显示在锚定 View 下方，否则显示在其上方</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val popupMenu by lazy &#123;
    val menu &#x3D; PopupMenu(this, toolbarFragment.viewShowMenu) &#x2F;&#x2F; 指定其弹出的位置
    menu.menuInflater.inflate(R.menu.main_config, menu.menu)
    menu
&#125;</code></pre>
<ol start="3">
<li>配置点击事件: 返回 True 表示点击事件被消耗</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">popupMenu.setOnMenuItemClickListener &#123;
    when(it.itemId) &#123;
        R.id.menu_info_by_day -&gt; &#123;
            TodoItemInfoByDayActivity.onActionStart(this)
            true
        &#125;
        else -&gt; &#123;
            true
        &#125;
    &#125;
&#125;</code></pre>
<ol start="4">
<li>配置点击显示 Menu: 使用 MenuPopupHelper 进一步封装, 是为了在每一个 Menu 项中显示 Icon <code>setForceShowIcon(true)</code></li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val menu &#x3D; MenuPopupHelper(this,
    (popupMenu.getMenu() as MenuBuilder), toolbarFragment.viewShowMenu)
menu.setForceShowIcon(true)
menu.show()</code></pre>
<h2 id="EditText">EditText</h2>
<ul>
<li>提示内容: <code>:hint=&quot;Type something here&quot;</code></li>
<li>最大行数: <code>:maxLines=&quot;1&quot;</code> 超过最大行数会滚动显示（组件不会拉伸）</li>
<li>内容过滤模板: <code>:inputType</code> 常用的有 <code>text, textPassword, number</code></li>
</ul>
<p>方法：</p>
<ul>
<li>获取内容: <code>edit_username.text.toString()</code></li>
<li>设置内容: <code>edit_username.setText(String)</code></li>
<li>设置光标位置: <code>edit_username.setSelection(Int)</code></li>
<li>请求 Focus: <code>requestFocus()</code></li>
<li>全选: <code>selectAll()</code></li>
</ul>
<h2 id="ImageView">ImageView</h2>
<ul>
<li>
<p>设定图片源: <code>:src=&quot;@drawable/image_demo_1&quot;</code></p>
</li>
<li>
<p>修改图片源: <code>.setImageResource(R.drawable.image_demo_2)</code></p>
</li>
</ul>
<h2 id="ProgressBar">ProgressBar</h2>
<h3 id="进度条样式">进度条样式</h3>
<ul>
<li>默认旋转加载进度条</li>
<li>水平进度条: <code>style=&quot;?android:attr/progressBarStyleHorizontal&quot;</code>
<ul>
<li>设定进度最大值: <code>:max=&quot;100&quot;</code></li>
<li>设定初始进度值: <code>:progress=&quot;50&quot;</code></li>
<li>获取进度值: <code>int progress = progressBarHorizontal.getProgress();</code></li>
<li>设置进度值: <code>progressBarHorizontal.setProgress(progress);</code></li>
</ul>
</li>
</ul>
<h2 id="AlertDialog">AlertDialog</h2>
<p>在当前界面弹出一个对话框, 置于所有界面元素之上(屏蔽其他控件的交互能力)</p>
<h3 id="二次确认">二次确认</h3>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">R.id.button_change_image -&gt; &#123;
    val environment &#x3D; this
    AlertDialog.Builder(this).apply &#123;
        setTitle(&quot;Warning&quot;)
        setMessage(&quot;Do you really want to change the image source?&quot;)
        &#x2F;&#x2F; 可否使用 Back 键关闭对话框
        setCancelable(true)
        setPositiveButton(&quot;YES&quot;) &#123; dialog, which -&gt;
            Toast.makeText(environment, &quot;Change Image&quot;, Toast.LENGTH_SHORT).show()
            val image_demo_1 &#x3D; findViewById&lt;ImageView&gt;(R.id.image_demo_1)
            image_demo_1.setImageResource(R.drawable.image_demo_2)
        &#125;
        setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; dialog.dismiss()&#125;
        show()
    &#125;

&#125;</code></pre>
<h3 id="列表选择">列表选择</h3>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val todoCategoryItems &#x3D; viewModel.todoCategoryList.map &#123; it.name &#125;.toTypedArray()
val alertBuilder: AlertDialog.Builder &#x3D; AlertDialog.Builder(this).apply &#123;
    setTitle(&quot;时间规划集&quot;)
    .setItems(todoCategoryItems, DialogInterface.OnClickListener &#123; dialog, which -&gt;
        insertTodoitmeCategory.setText(todoCategoryItems.get(which))
        dialog.dismiss()
    &#125;)
    create()
    show()
&#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202211091917520.jpg" alt=""></p>
<h2 id="ProgressDialog【OLD】">ProgressDialog【OLD】</h2>
<p>功能：弹出的对话框中显示一个进度条，缓解用户等待的焦躁。</p>
<p>构建方法：与AlertDialog类似</p>
<pre class="language-java" data-language="java"><code class="language-java">ProgressDialog progressDialog &#x3D; new ProgressDialog(MainActivity.this);

progressDialog.setTitle(&quot;Progress Dialog&quot;);
progressDialog.setMessage(&quot;Loading...&quot;);
progressDialog.setCancelable(true);

progressDialog.show();</code></pre>
<h1>布局</h1>
<h2 id="LinearLayout">LinearLayout</h2>
<ul>
<li>布局方向: <code>:orientation</code> 属性排列方向有 <code>vertical, horizontal</code></li>
<li>对齐方式: <code>:layout_gravity</code> 和文字在空间中的对齐方式类似
<ul>
<li>水平排列时, 水平长度不固定, 因此 <code>center</code> 会失效; 同理, …</li>
</ul>
</li>
<li>空间比例排布: <code>:layout_weight=&quot;1&quot;</code> 在一行或一列中按照比例分配大小, 自适应拉伸; 需要将 <code>:layout_width</code> 置为 0</li>
</ul>
<p>布局技巧: 先 Layout 后 组件</p>
<h2 id="RelativeLayout">RelativeLayout</h2>
<p>通过相对定位的方式让控件出现在布局的任何位置</p>
<p>根据父组件布局:</p>
<ul>
<li><code>:layout_alignParentLeft=&quot;true&quot;</code></li>
<li><code>:layout_alignParentRight=&quot;true&quot;</code></li>
<li><code>:layout_centerInParent=&quot;true&quot;</code></li>
<li><code>:layout_alignParentTop=&quot;true&quot;</code></li>
<li><code>:layout_alignParenBottom=&quot;true&quot;</code></li>
</ul>
<p>根据某一组件的位置布局:</p>
<ul>
<li><code>:layout_toRightOf=&quot;@+id/button_center&quot;</code></li>
<li><code>:layout_toLefttOf=&quot;@+id/button_center&quot;</code></li>
<li><code>:layout_above=&quot;@+id/button_center&quot;</code></li>
<li><code>:layout_below=&quot;@+id/button_center&quot;</code></li>
</ul>
<p>相对于组件对齐:</p>
<ul>
<li><code>:layout_alignLeft</code>: 两组件左边缘对齐</li>
<li><code>:layout_alignRight</code>: 两组件右边缘对齐</li>
<li><code>:layout_alignTop</code>: 两组件上边缘对齐</li>
<li><code>:layout_alignBottom</code>: 两组件下边缘对齐</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202207192024159.png" alt=""></p>
<h2 id="FrameLayout">FrameLayout</h2>
<p>帧布局, 所有的控件都会默认摆放在布局的左上角</p>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202207201944550.png" alt=""></p>
<h1>自定义控件</h1>
<p>所有控件都是直接或间接继承自 View:</p>
<ul>
<li>View 是 Android 中最基本的一种 UI 组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202207201947883.png" alt=""></p>
<p>Application:</p>
<ul>
<li>公共组件的复用 <code>&lt;include layout=&quot;@layout/title&quot; /&gt;</code>: 标题栏, 尾部栏
<ul>
<li>需要将系统自带的标题栏等进行隐藏: <code>supportActionBar?.hide()</code></li>
</ul>
</li>
<li>但是如果复用的组件中有交互性事件, 如何复用这些事件的响应操作呢, 引入了自定义控件</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class TitleLayout(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) &#123;

    init &#123;
        LayoutInflater.from(context).inflate(R.layout.title, this)

        val titleBack &#x3D; findViewById&lt;Button&gt;(R.id.titleBack)
        val titleText &#x3D; findViewById&lt;TextView&gt;(R.id.titleText)
        val titleEdit &#x3D; findViewById&lt;Button&gt;(R.id.titleEdit)
        titleBack.setOnClickListener &#123;
            val activity &#x3D; context as Activity
            activity.finish()
        &#125;
        titleEdit.setOnClickListener &#123;
            Toast.makeText(context, &quot;Editing...&quot;, Toast.LENGTH_SHORT).show()
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li><code>LayoutInflater</code> 对象用于实现动态加载, 通过 <code>LayoutInflater</code> 的 <code>from()</code> 方法可以构建出一个 <code>LayoutInflater</code> 对象，然后调用 <code>inflate()</code> 方法就可以动态加载一个布局文件
<ul>
<li>第一个参数是要加载的布局文件的 id</li>
<li>第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为 TitleLayout，于是直接传入 this</li>
</ul>
</li>
</ul>
<p>在布局文件中添加这个自定义控件, 即可将相关的事件处理也一并复用引入:</p>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;com.example.a05_uicustomviews.TitleLayout
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;wrap_content&quot;&#x2F;&gt;</code></pre>
<h1>ListView</h1>
<p>ListView 允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据会滚动出屏幕</p>
<h2 id="Quick-Start">Quick Start</h2>
<ol>
<li>准备好数据</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private val data &#x3D; listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;,
    &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot;,
    &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;,
    &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot;)</code></pre>
<ol start="2">
<li>封装到 adapter 中</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val adapter &#x3D; ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, data)</code></pre>
<ul>
<li>泛型通过数据类型指定为 <code>String</code></li>
<li>Context 参数为当前 Activity</li>
<li>resource: 参数指的是数据项的布局 id, 这里我们使用内置的 simple_list_item_1</li>
</ul>
<ol start="3">
<li>设置 adapter 到 listview 中</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">list_main.adapter &#x3D; adapter</code></pre>
<h2 id="adapter">adapter</h2>
<p>适配器, 是数据项与视图(展示)的桥梁, 即 MVC 中的 C(Controller): An Adapter object acts as a bridge between an AdapterView and the underlying data for that view. The Adapter provides access to the data items. The Adapter is also responsible for making a View for each item in the data set.</p>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202207282231794.png" alt=""></p>
<p>常用有 <code>ArrayAdapter</code>, <code>CursorAdapter</code>, <code>SimpleCursorAdapter</code> 不同的类定义了不同的数据展示形式</p>
<h2 id="自定义-adapter">自定义 adapter</h2>
<p>主要是自定义数据项的显示界面</p>
<ol>
<li>首先对我们的数据项中的数据进行封装</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class Fruit(val name:String, val imageId: Int) &#123;
&#125;</code></pre>
<ol start="2">
<li>然后编写数据项的 Layout (作为 Adapter 的参数)</li>
</ol>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;!-- 左图右文字 --&gt;
&lt;LinearLayout ...&gt;

    &lt;ImageView ...&#x2F;&gt;

    &lt;TextView ...&#x2F;&gt;

&lt;&#x2F;LinearLayout&gt;</code></pre>
<ol start="3">
<li>自定义 Adapter: 在 ArrayAdapter 的基础上自定义展示视图</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class FruitAdapter(activity: Activity, val resourceId: Int, data: List&lt;Fruit&gt;): ArrayAdapter&lt;Fruit&gt;(activity, resourceId, data) &#123;

    inner class ViewHolder(val fruitImage: ImageView, val fruitName: TextView)

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123;
        val view: View
        val viewHolder: ViewHolder
        if (convertView &#x3D;&#x3D; null) &#123;
            view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)
            val image_fruit_item: ImageView &#x3D; view.findViewById(R.id.image_fruit_item)
            val text_fruit_name:TextView &#x3D; view.findViewById(R.id.text_fruit_name)
            viewHolder &#x3D; ViewHolder((image_fruit_item, text_fruit_name))
            view.tag &#x3D; viewHolder
        &#125; else &#123;
            view &#x3D; convertView
            viewHolder &#x3D; view.tag as ViewHolder
        &#125;
        val fruit &#x3D; getItem(position)
        if (fruit !&#x3D; null) &#123;
            viewHolder.fruitImage.setImageResource(fruit.imageId)
            viewHolder.fruitName.text &#x3D; fruit.name
        &#125;
        return view
    &#125;

&#125;</code></pre>
<ol start="4">
<li>Apply Adapter to data</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private val fruitList &#x3D; ArrayList&lt;Fruit&gt;()
    override fun onCreate(savedInstanceState: Bundle?) &#123;
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        supportActionBar?.hide()

        val list_main &#x3D; findViewById&lt;ListView&gt;(R.id.list_main)

        initFruits()
        val adapter &#x3D; FruitAdapter(this, R.layout.fruit_item, fruitList)
        list_main.adapter &#x3D; adapter
    &#125;

    private fun initFruits() &#123;
        repeat(2) &#123;
            fruitList.add(Fruit(&quot;Cherry&quot;, R.drawable.cherry_pic))
            fruitList.add(Fruit(&quot;Mango&quot;, R.drawable.mango_pic))
            ...
        &#125;
    &#125;</code></pre>
<h3 id="Adapter-性能优化过程">Adapter 性能优化过程</h3>
<p>这是最初的 Adapter 编写思路:</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 继承与构造函数 - kotlin 基础
class FruitAdapter(activity: Activity, val resourceId: Int, data: List&lt;Fruit&gt;): ArrayAdapter&lt;Fruit&gt;(activity, resourceId, data) &#123;
    &#x2F;&#x2F; 需要加载数据项时调用, 但是每次调用时都会将数据项布局(resourceId)重新加载一遍
    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123;
        &#x2F;&#x2F; 加载新的数据项: 使用 LayoutInflater 加载数据项对应的布局
        &#x2F;&#x2F; 第一个参数是要加载的布局文件的 id - 实例化 Adapter 时传入的参数
        &#x2F;&#x2F; 第二个参数是给加载好的布局再添加一个父布局，这里回调函数中带有父布局的 id 直接使用
        &#x2F;&#x2F; 第三个参数为 false 时 ListView 中的标准写法, 表示只让我们在父布局中声明的 layout 属性生效，但不会为这个 View 添加父布局, 因为一旦 View 有了父布局之后，它就不能再添加到 ListView 中了
        val view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)
        &#x2F;&#x2F; 完成 View 的加载即可获取 View 中的组件
        val image_fruit_item: ImageView &#x3D; view.findViewById(R.id.image_fruit_item)
        val text_fruit_name:TextView &#x3D; view.findViewById(R.id.text_fruit_name)
        &#x2F;&#x2F; 根据 position 加载对应的数据项 - 步骤 1 封装后的实例
        val fruit &#x3D; getItem(position)
        &#x2F;&#x2F; 成功加载后渲染到 view 中
        if (fruit !&#x3D; null) &#123;
            image_fruit_item.setImageResource(fruit.imageId)
            text_fruit_name.text &#x3D; fruit.name
        &#125;
        return view
    &#125;
&#125;</code></pre>
<p>Tips: getView 默认每次调用时都会将数据项布局重新加载一遍, 因此当快速滑动时将会对性能有所影响, 但是每个数据项的布局基本是一致的, 因此我们可以借助对之前布局的缓存 <code>convertView</code> 进行优化</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val view: View
if (convertView &#x3D;&#x3D; null) &#123;
    view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)
&#125; else &#123;
    view &#x3D; convertView
&#125;
&#x2F;&#x2F; 后续依旧是对布局的数据绑定 ...</code></pre>
<p>Tips: 继续观察代码我们发现针对布局中的控件我们每次还是需要 <code>find</code>, 可以借助 <code>ViewHolder</code> 对这部分性能进行优化</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 自定义一个内部类实现对目标控件组的封装
inner class ViewHolder(val fruitImage: ImageView, val fruitName: TextView)

override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123;
    val view: View
    val viewHolder: ViewHolder
    &#x2F;&#x2F; 如果之前不存在 View 的缓存则加载 View 并寻找绑定控件
    if (convertView &#x3D;&#x3D; null) &#123;
        view &#x3D; LayoutInflater.from(context).inflate(resourceId, parent, false)
        val image_fruit_item: ImageView &#x3D; view.findViewById(R.id.image_fruit_item)
        val text_fruit_name:TextView &#x3D; view.findViewById(R.id.text_fruit_name)
        viewHolder &#x3D; ViewHolder((image_fruit_item, text_fruit_name))
        view.tag &#x3D; viewHolder
    &#125; else &#123;
    &#x2F;&#x2F; 否则直接加载
        view &#x3D; convertView
        viewHolder &#x3D; view.tag as ViewHolder
    &#125;
    val fruit &#x3D; getItem(position)
    if (fruit !&#x3D; null) &#123;
        viewHolder.fruitImage.setImageResource(fruit.imageId)
        viewHolder.fruitName.text &#x3D; fruit.name
    &#125;
    return view
&#125;</code></pre>
<h2 id="点击事件">点击事件</h2>
<p>ListView 的点击事件会冒泡到 ListView 对象上进行统一处理:</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">list_main.setOnItemClickListener &#123; adapterView, view, i, l -&gt;
    val fruitItem &#x3D; fruitList[i]
    Toast.makeText(this, fruitItem.name, Toast.LENGTH_SHORT).show()
&#125;
&#x2F;&#x2F; Tips 不用到的参数可以都使用 _ 替代
list_main.setOnItemClickListener &#123; _, _, i, _ -&gt;
    val fruitItem &#x3D; fruitList[i]
    Toast.makeText(this, fruitItem.name, Toast.LENGTH_SHORT).show()
&#125;</code></pre>
<h1>RecyclerView</h1>
<p>(Why) ListView 在性能, 扩展性等方面存在限制, 因此 Android 提供了更强大的 RecycleView 替代并增强了 ListView(不删除是为了向下适应老版本)</p>
<h2 id="Quick-Start-2">Quick Start</h2>
<ol>
<li>
<p>准备好数据项的布局</p>
</li>
<li>
<p>创建 Adapter 类：实现 ViewHoder 的声明与定义, 子项的赋值等基本功能</p>
</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">
class RecyclerFruitAdapter(val fruitList: List&lt;Fruit&gt;) : RecyclerView.Adapter&lt;RecyclerFruitAdapter.ViewHolder&gt;() &#123;
    &#x2F;&#x2F; 内部类 ViewHolder
    &#x2F;&#x2F; 主构造函数中要传入一个 View 参数 作为 RecyclerView 子项的最外层布局
    inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) &#123;
        val fruitImage: ImageView &#x3D; view.findViewById(R.id.image_fruit_item)
        val fruitName: TextView &#x3D; view.findViewById(R.id.text_fruit_name)
    &#125;

    &#x2F;&#x2F; 创建 ViewHoldedr 实例
    &#x2F;&#x2F; 实现对 子项布局的加载
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123;
        val view &#x3D; LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, false)
        return ViewHolder(view)
    &#125;

    &#x2F;&#x2F; 对子项进行赋值
    override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123;
        val fruit &#x3D; fruitList[position]
        holder.fruitImage.setImageResource(fruit.imageId)
        holder.fruitName.text &#x3D; fruit.name
    &#125;

    &#x2F;&#x2F; 子项的数目
    override fun getItemCount() &#x3D; fruitList.size
&#125;</code></pre>
<ol start="3">
<li>为 RecyclerView 指定父布局和 adapter</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val recyclerView &#x3D; findViewById&lt;RecyclerView&gt;(R.id.recyclerView)
val layoutManager &#x3D; LinearLayoutManager(this)
recyclerView.layoutManager &#x3D; layoutManager
val adapter &#x3D; RecyclerFruitAdapter(fruitList)
recyclerView.adapter &#x3D; adapter</code></pre>
<h2 id="扩展布局">扩展布局</h2>
<h3 id="水平排列">水平排列</h3>
<ol>
<li>首先设置好数据子项的布局，至少水平排列时不能占一满行</li>
<li>然后再去设置 RecyclerView 的父布局即可</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val layoutManager &#x3D; LinearLayoutManager(this)
layoutManager.orientation &#x3D; LinearLayoutManager.HORIZONTAL
recyclerView.layoutManager &#x3D; layoutManager</code></pre>
<h3 id="瀑布流布局">瀑布流布局</h3>
<ol>
<li>设置好子项的布局</li>
</ol>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;
    android:orientation&#x3D;&quot;vertical&quot;
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;wrap_content&quot;
    android:layout_margin&#x3D;&quot;5dp&quot;&gt;

    &lt;ImageView
        android:layout_width&#x3D;&quot;40dp&quot;
        android:layout_height&#x3D;&quot;40dp&quot;
        android:id&#x3D;&quot;@+id&#x2F;image_fruit_item&quot;
        android:layout_gravity&#x3D;&quot;center_horizontal&quot;
        android:layout_marginTop&#x3D;&quot;10dp&quot;
        &#x2F;&gt;

    &lt;TextView
        android:layout_width&#x3D;&quot;wrap_content&quot;
        android:layout_height&#x3D;&quot;wrap_content&quot;
        android:id&#x3D;&quot;@+id&#x2F;text_fruit_name&quot;
        android:layout_gravity&#x3D;&quot;left&quot;
        android:layout_marginTop&#x3D;&quot;10dp&quot;
        &#x2F;&gt;

&lt;&#x2F;LinearLayout&gt;</code></pre>
<ol start="2">
<li>使用 <code>StaggeredGridLayoutManager</code></li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val recyclerView &#x3D; findViewById&lt;RecyclerView&gt;(R.id.recyclerView)
val layoutManager &#x3D; StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL)
recyclerView.layoutManager &#x3D; layoutManager</code></pre>
<h2 id="点击事件-2">点击事件</h2>
<p>Recycler 为了更精细的控制, 将点击事件的绑定精细到了每一个子项, 在生成子项布局 <code>onCreateViewHolder</code> 时进行定义</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; itemView 表示最外层的布局
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123;
    val view &#x3D; LayoutInflater.from(parent.context).inflate(R.layout.todoitem_card, parent, false)
    val holder &#x3D; ViewHolder(view)
    holder.itemView.setOnClickListener &#123;
        val position &#x3D; holder.adapterPosition
        val todoItem &#x3D; todoItemList[position]
        startTodoItemInfo(todoItem.id, todoItem.name)
    &#125;
    return holder
&#125;</code></pre>
<h2 id="滑动事件">滑动事件</h2>
<p>这里以滑动删除事件为例进行简单介绍</p>
<ol>
<li>首先要建立自己的类, 继承 <code>ItemTouchHelper.XXCallback</code> 这些回调方法, 并实现回调处理, 其中 onSwiped 就是滑动的检测; 两个参数分别为拖动的方向(一般实现两个组件间位置交互)与滑动(一般实现目标组件的交互)的方向, 0 表示不可拖动或滑动, 具体方向由 ItemTouchHelper 中的静态属性分配</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class BookItemTouchHelperCallback(var adapter: RecyclerBookAdapter): ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.LEFT) &#123;
    override fun onMove(
        recyclerView: RecyclerView,
        viewHolder: RecyclerView.ViewHolder,
        target: RecyclerView.ViewHolder
    ): Boolean &#123;
        TODO(&quot;Not yet implemented&quot;)
    &#125;

    override fun onSwiped(viewHolder: RecyclerView.ViewHolder, direction: Int) &#123;
        var pos &#x3D; viewHolder.adapterPosition
        adapter.deleteItem(pos)
    &#125;
&#125;</code></pre>
<ol start="2">
<li>然后借助回调方法的实例创建 <code>ItemTouchHelper</code> 实例, 并绑定到目标 <code>RecyclerView</code> 上</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val itemTouchHelper &#x3D; ItemTouchHelper(BookItemTouchHelperCallback(adapter))
itemTouchHelper.attachToRecyclerView(recycler)</code></pre>
<h1>Android 图标</h1>
<p>应用程序的图标应该被分为两层：前景层和背景层</p>
<ul>
<li>前景层用来展示应用图标的 Logo:</li>
<li>Mask 层: 在图标的前景层和背景层之间, 手机厂商负责定义</li>
<li>背景层用来衬托应用图标的 Logo: 只允许定义颜色和纹理，不能定义形状</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202209181547481.png" alt=""></p>
<ol>
<li>res 目录处右击 new/Image_Asssert</li>
<li>修改前景的 Logo 图片与背景色</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202209181604700.png" alt=""></p>
<h1>Android 签名文件</h1>
<h2 id="Android-Studio-生成">Android Studio 生成</h2>
<ol>
<li>Build/Generate Singed Bundle/APK</li>
</ol>
<ul>
<li>Android App Bundle 文件是用于上架 Google Play 商店的</li>
<li>APK for Android</li>
</ul>
<ol start="2">
<li>填入 keystore 文件的路径和密码</li>
<li>Create New…</li>
</ol>
<ul>
<li>Validity 是 keystore 文件的有效时长，单位是年</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202209181614822.png" alt=""></p>
<h2 id="Gradle-生成-Ignore">Gradle 生成 [Ignore]</h2>
<ol>
<li>编辑 app/build.gradle 文件</li>
</ol>
</div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://jiancongcui.github.io/2022/08/07/04-Android-UI/,Jiancong Cui,04-Android-UI,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/08/18/05-Fragment/" title="05-Fragment">prev_post</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/07/18/03-Android-Activity/" title="03-Android-Activity">next_post</a></li></ul></div></div></div><div class="footer animated fadeInDown"><div class="p"> <span>© 2024 - 2029 </span><i class="fa fa-star"></i><span> JCC</span></div><div class="by_farbox"><span>Powered by </span><a href="https://sites.google.com/new" target="_blank">Google Sites </a><span> & </span><a href="https://github.com/Ben02/hexo-theme-Anatole" target="_blank">Ben </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core </a></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>