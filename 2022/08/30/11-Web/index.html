<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="JCC"><title>11-Web · Jiancong Cui</title><meta name="description" content="WebView
WebView 空间可以实现应用程序内浏览器的嵌入以及网页的展示
Quick Start

Layout

&amp;lt;WebView
    android:id&amp;#x3D;&amp;quot;@+id&amp;#x2F;webView&amp;quot;
    android:layout_width&amp;#"><meta name="keywords" content="Computer Science, Privacy Security,"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&amp;display=swap"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/tag.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="shortcut icon" href="/images/jcc.webp"><script src="/js/jquery.js"></script><!-- 主题：可换 one-dark/tomorrow/github 等 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css">
<!-- 行号 + 工具栏的样式 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.css">
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/show-language/prism-show-language.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="page-top animated fadeInDown"><div class="nav-container"> <div class="nav"><a class="nav-item logo" href="/">Jiancong Cui </a><a class="nav-item" href="/">About Me</a><a class="nav-item" href="/blogs">Posts</a><a class="nav-item" href="/archives">Archive</a><a class="nav-item" href="/tags">Tags</a><a class="nav-item" href="/quotes">Quotes</a></div></div></div><div id="main-container"><div class="main-content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><a>11-Web</a></div><div class="post-labels"><div class="label-item"> <i class="fa fa-clock-o"></i><span class="date">2022-08-30</span></div><div class="label-item"> <i class="fa fa-list"></i><a class="tag" href="/categories/Android-Dev/" title="Android Dev.">Android Dev.</a></div><div class="label-item"><i class="fa fa-bookmark"></i><a class="tag" href="/tags/Android/" title="Android">Android</a></div><span class="leancloud_visitors"></span></div><div class="post-content"><h1>WebView</h1>
<p>WebView 空间可以实现应用程序内浏览器的嵌入以及网页的展示</p>
<h2 id="Quick-Start">Quick Start</h2>
<ol>
<li>Layout</li>
</ol>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;WebView
    android:id&#x3D;&quot;@+id&#x2F;webView&quot;
    android:layout_width&#x3D;&quot;match_parent&quot;
    android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;</code></pre>
<ol start="2">
<li>loadUrl: 其中 WebViewClient() 的设置是希望当从一个网页跳转到另一个网页时，希望目标网页仍然在当前 WebView 中显示，而不是打开系统浏览器</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">R.id.buttonLoadBaidu -&gt; &#123;
    webView.settings.javaScriptEnabled &#x3D; true
    webView.webViewClient &#x3D; WebViewClient()
    webView.loadUrl(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)
&#125;</code></pre>
<ol start="3">
<li>Permission</li>
</ol>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;</code></pre>
<h1>HTTP in Android</h1>
<h2 id="Quick-Start-2">Quick Start</h2>
<ol>
<li>发送 HTTP 请求: 创建一个子线程完成请求的发送与响应的获取</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private fun sendRequestWithHttpURLConnection() &#123;
    thread &#123;
        var connection: HttpURLConnection? &#x3D; null
        try &#123;
            val response &#x3D; StringBuilder()
            val url &#x3D; URL(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)
            connection &#x3D; url.openConnection() as HttpURLConnection

            connection.requestMethod &#x3D; &quot;GET&quot;
            connection.connectTimeout &#x3D; 8000 &#x2F;&#x2F;ms
            connection.readTimeout &#x3D; 8000

            &#x2F;&#x2F; 响应获取
            val input &#x3D; connection.inputStream
            val reader &#x3D; BufferedReader(InputStreamReader(input))
            reader.use &#123;
                reader.forEachLine &#123;
                    response.append(it)
                &#125;
            &#125;
            showResponse(response.toString())
        &#125; catch (e: Exception) &#123;
            e.printStackTrace()
        &#125; finally &#123;
            connection?.disconnect()
        &#125;
    &#125;

    &#x2F;&#x2F; 子线程与 UI 交互的封装
    private fun showResponse(response: String) &#123;
        runOnUiThread &#123;
            &#x2F;&#x2F; UI 操作线程
            responseText.setText(response)
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="Post-Data">Post Data</h2>
<p>将 connection 对象的请求方法设置为 POST 后即可通过 outputStream 进行数据的发送</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">connection.requestMethod &#x3D; &quot;POST&quot; &#x2F;&#x2F; 可以提交数据
val output &#x3D; DataOutputStream(connection.outputStream)
output.writeBytes(&quot;username&#x3D;admin&amp;password&#x3D;123456&quot;)</code></pre>
<h2 id="OkHTTP">OkHTTP</h2>
<p>超越原生 HttpURLConnection 的外部开源库</p>
<h3 id="Quick-Start-3">Quick Start</h3>
<ol>
<li><code>app/build.gradle</code> 中添加依赖</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">implementation &#39;com.squareup.okhttp3:okhttp:4.1.0&#39;</code></pre>
<ol start="2">
<li>client + request + response + responseData</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val client &#x3D; OkHttpClient()
val request &#x3D; Request.Builder()
    .url(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)
    .build()
val response &#x3D; client.newCall(request).execute()
val responseData &#x3D; response.body?.string()
if (responseData !&#x3D; null) &#123;
    showResponse(responseData)
&#125;</code></pre>
<h3 id="Post-data">Post data</h3>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val requestBody &#x3D; FormBody.Builder()
    .add(&quot;username&quot;, &quot;admin&quot;)
    .add(&quot;password&quot;, &quot;123456&quot;)
    .build()
val requestPost &#x3D; Request.Builder()
    .url(&quot;https:&#x2F;&#x2F;www.baidu.com&quot;)
    .post(requestBody)kotlin
    .build()</code></pre>
<h3 id="HTTP">HTTP</h3>
<p>HTTP 明文传输默认不支持, 需要在 <code>res/xml</code> 中手动写一个配置文件 <code>network_config.xml</code> 并应用</p>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;network-security-config&gt;
    &lt;base-config cleartextTrafficPermitted&#x3D;&quot;true&quot;&gt;
        &lt;trust-anchors&gt;
            &lt;certificates src&#x3D;&quot;system&quot; &#x2F;&gt;
        &lt;&#x2F;trust-anchors&gt;
    &lt;&#x2F;base-config&gt;
&lt;&#x2F;network-security-config&gt;</code></pre>
<p>在 AndroidManifest 中应用</p>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;application
    ...
    android:networkSecurityConfig&#x3D;&quot;@xml&#x2F;network_config&quot;
    &#x2F;&gt;</code></pre>
<h1>XML Parser</h1>
<p>在网络上传输数据时最常用的格式有两种：XML 和 JSON, 先来了解下 Android 关于 XML 解析的相关知识</p>
<h2 id="Pull-解析">Pull 解析</h2>
<p>首先时请求获取 XML 相关数据</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private fun parseXMLTest() &#123;
    thread &#123;
        try &#123;
            val client &#x3D; OkHttpClient()
            val request &#x3D; Request.Builder()
                .url(&quot;http:&#x2F;&#x2F;192.168.0.107&#x2F;DVWA&#x2F;get_data.xml&quot;)
                .build()
            val response &#x3D; client.newCall(request).execute()
            val responseData &#x3D; response.body?.string()
            if (responseData !&#x3D; null) &#123;
                val xmlData &#x3D; parseXMLWithPull(responseData)
                showResponse(xmlData)
            &#125;
        &#125; catch (e: Exception) &#123;
            e.printStackTrace()
        &#125;
    &#125;
&#125;</code></pre>
<p>然后对 XML 数据进行解析</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private fun parseXMLWithPull(xmlData: String): String &#123;
    val retXmlData &#x3D; StringBuilder()
    try &#123;
        &#x2F;&#x2F; 创建工厂类实例, 获取解析对象: xmlPullParse
        val factory &#x3D; XmlPullParserFactory.newInstance()
        val xmlPullParser &#x3D; factory.newPullParser()
        &#x2F;&#x2F; 设置解析内容:
        xmlPullParser.setInput(StringReader(xmlData))
        &#x2F;&#x2F; 获得初始的解析状态
        var eventType &#x3D; xmlPullParser.eventType
        var id &#x3D; &quot;&quot;
        var name &#x3D; &quot;&quot;
        var version &#x3D; &quot;&quot;
        &#x2F;&#x2F; 解析循环判停条件
        while (eventType !&#x3D; XmlPullParser.END_DOCUMENT) &#123;
            &#x2F;&#x2F; getName 获取当前解析节点的名称
            val nodeName &#x3D; xmlPullParser.name
            when (eventType) &#123;
                &#x2F;&#x2F; 根据开始节点的名称进行处理
                XmlPullParser.START_TAG -&gt; &#123;
                    &#x2F;&#x2F; 简单的根据开始节点名称获取节点中的值
                    when (nodeName) &#123;
                        &quot;id&quot; -&gt; id &#x3D; xmlPullParser.nextText()
                        &quot;name&quot; -&gt; name &#x3D; xmlPullParser.nextText()
                        &quot;version&quot; -&gt; version &#x3D; xmlPullParser.nextText()
                    &#125;
                &#125;
                &#x2F;&#x2F; 根据结束节点的名称进行处理
                XmlPullParser.END_TAG -&gt; &#123;
                    &#x2F;&#x2F; 结束节点为 app 时表示一个 app 的值获取完毕, 进行输出封装
                    if (&quot;app&quot; &#x3D;&#x3D; nodeName) &#123;
                        retXmlData.append(&quot;id is $id + name is $name + version is $version\n&quot;)
                    &#125;
                &#125;
            &#125;
            &#x2F;&#x2F; 获取下一个解析事件类型
            eventType &#x3D; xmlPullParser.next()
        &#125;
    &#125; catch (e: Exception) &#123;
        e.printStackTrace()
    &#125;
    return retXmlData.toString()
&#125;</code></pre>
<h2 id="SAX-解析方式">SAX 解析方式</h2>
<p>用法比 Pull 更复杂, 但是语义更清楚</p>
<ol>
<li>需要继承 DefaultHandler 类并实现相关处理方法</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class XMLContentHandler: DefaultHandler() &#123;

    private var nodeName &#x3D; &quot;&quot;
    private var retXMLData &#x3D; StringBuilder()
    private lateinit var id: StringBuilder
    private lateinit var name: StringBuilder
    private lateinit var version: StringBuilder

    &#x2F;&#x2F; 开始解析 XML 前调用
    override fun startDocument() &#123;
        id &#x3D; StringBuilder()
        name &#x3D; StringBuilder()
        version &#x3D; StringBuilder()
    &#125;

    &#x2F;&#x2F; 针对一个节点的解析
    override fun startElement(
        uri: String?,
        localName: String?, &#x2F;&#x2F; 节点名称
        qName: String?,
        attributes: Attributes?
    ) &#123;
        if (localName &#x3D;&#x3D; null) return
        nodeName &#x3D; localName
        retXMLData.apply &#123;
            append(&quot;uri is $uri\n&quot;)
            append(&quot;localname is $localName\n&quot;)
            append(&quot;qName is $qName\n&quot;)
            append(&quot;attributes is $attributes\n&quot;)
        &#125;
    &#125;

    &#x2F;&#x2F; 针对节点中内容的解析
    override fun characters(ch: CharArray?, start: Int, length: Int) &#123;
        &#x2F;&#x2F; 通过 startElement 中记录的节点名称, 将内容添加到相应容器中
        when (nodeName) &#123;
            &quot;id&quot; -&gt; id.append(ch, start, length)
            &quot;name&quot; -&gt; name.append(ch, start, length)
            &quot;version&quot; -&gt; version.append(ch, start, length)
        &#125;
    &#125;

    &#x2F;&#x2F; 完成某个节点解析时调用
    override fun endElement(uri: String?, localName: String?, qName: String?) &#123;
        if (&quot;app&quot; &#x3D;&#x3D; localName) &#123;
            retXMLData.append(&quot;id is $&#123;id.toString().trim()&#125; @ name is $&#123;name.toString().trim()&#125; @ version is $&#123;version.toString().trim()&#125;\n&quot;)
            id.setLength(0)
            name.setLength(0)
            version.setLength(0)
        &#125;
    &#125;

    &#x2F;&#x2F; 完成整个 xml 解析时调用
    override fun endDocument() &#123;
        super.endDocument()
    &#125;

    fun getRetXMLData(): String &#123;
        return this.retXMLData.toString()
    &#125;

&#125;</code></pre>
<ol start="2">
<li>在 SAXParser 中应用 contentHandler 进行 parse</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private fun parseXMLWithSAX(xmlData: String): String &#123;
    var retXMLData &#x3D; &quot;&quot;
    try &#123;
        val factory &#x3D; SAXParserFactory.newInstance()
        val xmlReader &#x3D; factory.newSAXParser().xmlReader
        val handler &#x3D; XMLContentHandler()
        xmlReader.contentHandler &#x3D; handler
        xmlReader.parse(InputSource(StringReader(xmlData)))
        retXMLData &#x3D; handler.getRetXMLData()
    &#125; catch (e: Exception) &#123;
        e.printStackTrace()
    &#125;
    return retXMLData
&#125;</code></pre>
<h1>JSON Parser</h1>
<p>JSON 体积更小，在网络上传输的时候更省流量，但语义性较差，不如 XML 直观</p>
<h2 id="JSONObject-解析">JSONObject 解析</h2>
<p>解析的方式十分简单, 将 JSON 字符串转为 JSONArray 对象, 遍历按类型解析即可</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val retJsonData &#x3D; StringBuilder()
try &#123;
    val jsonArray &#x3D; JSONArray(jsonData)
    for (i in 0 until jsonArray.length()) &#123;
        val jsonObject &#x3D; jsonArray.getJSONObject(i)
        val id &#x3D; jsonObject.getString(&quot;id&quot;)
        val name &#x3D; jsonObject.getString(&quot;name&quot;)
        val version &#x3D; jsonObject.getString(&quot;version&quot;)
        retJsonData.append(&quot;id is $id | name is $name | version is $version\n&quot;)
    &#125;
&#125; catch (e: Exception) &#123;
    e.printStackTrace()
&#125;
return retJsonData.toString()</code></pre>
<h2 id="GSON-解析">GSON 解析</h2>
<ol>
<li><code>app\build.gradle</code> 中添加依赖</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">implementation &#39;com.google.code.gson:gson:2.8.5&#39;</code></pre>
<ol start="2">
<li>为 JSON 数据建立一个 Bean 类</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class Book(var id: Int, var name: String, var version: String) &#123;&#125;</code></pre>
<ol start="3">
<li>使用 GSON 的实例进行解析</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private fun parseJsonWithGSON(jsonData: String): String &#123;
    val retJsonData &#x3D; StringBuilder()
    val gson &#x3D; Gson()
    &#x2F;&#x2F; 解析单个数据
    &#x2F;&#x2F; val book &#x3D; gson.fromJson(jsonData, Book::class.java)
    &#x2F;&#x2F; 解析多个(数组)数据
    &#x2F;&#x2F; 防止 List&lt;Book&gt; 中 Book 类型被擦除
    &#x2F;&#x2F; TypeToken 是个类, 我们使用 object: TypeToken&lt;List&lt;Book&gt;&gt;() &#123;&#125; 定义了其匿名类, 然后获取了这个类的 type 属性
    &#x2F;&#x2F; 相当于用一个子类 SubList extends List&lt;String&gt; 将父类中的泛型给保存
    val typeOf &#x3D; object: TypeToken&lt;List&lt;Book&gt;&gt;() &#123;&#125;.type
    val books &#x3D; gson.fromJson&lt;List&lt;Book&gt;&gt;(jsonData, typeOf)
    books.forEach &#123;
        retJsonData.append(&quot;id is $&#123;it.id&#125; @ name is $&#123;it.name&#125; @ version is $&#123;it.version&#125;\n&quot;)
    &#125;
    return retJsonData.toString()
&#125;</code></pre>
<h2 id="GSON-处理复杂数据">GSON 处理复杂数据</h2>
<p>如果是时间等复杂对象的需要手动配置针对目标对象的 Serializer 与 Deseralizer</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val todoGson &#x3D; GsonBuilder()
    .registerTypeAdapter(LocalDateTime::class.java, &#x2F;&#x2F; 对 LocalDateTime 添加 Serializer
        object : JsonSerializer&lt;LocalDateTime&gt; &#123;
            override fun serialize(
                src: LocalDateTime?,
                typeOfSrc: Type?,
                context: JsonSerializationContext?
            ): JsonElement &#123;
                return JsonPrimitive(src?.toLong()) &#x2F;&#x2F; toLong 是我对 LocalDateTime 添加的方法, 转为了 millsSecond
            &#125;

        &#125;
    ).registerTypeAdapter(LocalDateTime::class.java, &#x2F;&#x2F; 对 LocalDateTime 添加 Deserializer
        object : JsonDeserializer&lt;LocalDateTime&gt; &#123;
        override fun deserialize(
            json: JsonElement?,
            typeOfT: Type?,
            context: JsonDeserializationContext?
        ): LocalDateTime &#123;
            return json!!.asJsonPrimitive.asString.toLong().toLocalDateTime() &#x2F;&#x2F; 获取 json 存储的 long 格式数据，转为 LocalDatetime
        &#125;
    &#125;).serializeNulls().create()

&#x2F;&#x2F; to Json
val dbJson &#x3D; todoGson.toJson(dbInJson)
&#x2F;&#x2F; back to obj
val dbInJson &#x3D; todoGson.fromJson(dbJson, DBInJson::class.java)</code></pre>
<h1>网络请求的封装</h1>
<p>新建一个工具类对网络请求进行封装, 但是因为是多线程任务, 要再事件完成或失败时进行相应的回调处理, 因此需要定义相关的回调接口, 或实现相关库提供的回调接口</p>
<p>相关的回调接口</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">interface HttpCallbackListener &#123;
    fun onFinish(response: String)
    fun onError(e: Exception)
&#125;</code></pre>
<p>整体工具类的实现</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">object HttpUtil &#123;

    fun sendHttpRequest(address: String, callbackListener: HttpCallbackListener) &#123;
        thread &#123;
            var connection: HttpURLConnection? &#x3D; null
            try &#123;
                val response &#x3D; StringBuilder()
                var url &#x3D; URL(address)
                connection &#x3D; url.openConnection() as HttpURLConnection
                connection.connectTimeout &#x3D; 8000
                connection.readTimeout &#x3D; 8000
                val input &#x3D; connection.inputStream
                val reader &#x3D; BufferedReader(InputStreamReader(input))
                reader.use &#123;
                    reader.forEachLine &#123;
                        response.append(it)
                    &#125;
                &#125;
                callbackListener.onFinish(response.toString())
            &#125; catch (e: Exception) &#123;
                e.printStackTrace()
                callbackListener.onError(e)
            &#125; finally &#123;
                connection?.disconnect()
            &#125;
        &#125;

    &#125;

    fun sendOkHttpRequest(address: String, callbackListener: okhttp3.Callback) &#123;
        val client &#x3D; OkHttpClient()
        val request &#x3D; Request.Builder()
            .url(address)
            .build()
        &#x2F;&#x2F; OkHttp 在 enqueue() 方法的内部已经帮我们开好子线程了，然后会在子线程中执行 HTTP 请求，并将最终的请求结果回调到 okhttp3.Callback 当中
        client.newCall(request).enqueue(callbackListener)
    &#125;
&#125;</code></pre>
<h1>网络库 Retrofit</h1>
<h2 id="Quick-Start-4">Quick Start</h2>
<ol>
<li><code>app/build.gradle</code> 中添加依赖</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">implementation &#39;com.squareup.retrofit2:retrofit:2.6.1&#39;
implementation &#39;com.squareup.retrofit2:converter-gson:2.6.1&#39;</code></pre>
<ol start="2">
<li>封装好要请求的对象</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class Book(val id: String, val name: String, val version: String) &#123;&#125;</code></pre>
<ol start="3">
<li>定义请求接口</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">interface BookService &#123;

    @GET(&quot;&#x2F;DVWA&#x2F;get_data.json&quot;)
    &#x2F;&#x2F; 返回值必须声明成 Retrofit 中内置的 Call 类型
    fun getBookData(): Call&lt;List&lt;Book&gt;&gt;
&#125;</code></pre>
<ol start="4">
<li>触发服务器请求: 传入服务器根地址获取 Retrofit 对象 + 创建服务对象 + 调用服务获取数据</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">buttonGetBookData.setOnClickListener &#123;
    val retrofit &#x3D; Retrofit.Builder()
        .baseUrl(&quot;http:&#x2F;&#x2F;192.168.0.107&#x2F;&quot;)
        &#x2F;&#x2F; 用于指定 Retrofit 在解析数据时所使用的转换库，这里指定成 GsonConverterFactory - 获取的是 JSON 数据
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    val appService &#x3D; retrofit.create(BookService::class.java)
    appService.getBookData().enqueue(object : Callback&lt;List&lt;Book&gt;&gt; &#123;

        override fun onResponse(call: Call&lt;List&lt;Book&gt;&gt;, response: Response&lt;List&lt;Book&gt;&gt;) &#123;
            &#x2F;&#x2F; 自动的多线程操作
            &#x2F;&#x2F; 当发起请求的时候，Retrofit 会自动在内部开启子线程，当数据回调到 Callback 中之后，Retrofit 又会自动切换回主线
            val list &#x3D; response.body()
            if (list !&#x3D; null) &#123;
                for (book in list) &#123;
                    Log.d(&quot;MainActivity&quot;, &quot;id is $&#123;book.id&#125;&quot;)
                    Log.d(&quot;MainActivity&quot;, &quot;name is $&#123;book.name&#125;&quot;)
                    Log.d(&quot;MainActivity&quot;, &quot;version is $&#123;book.version&#125;&quot;)
                &#125;
            &#125;
        &#125;

        override fun onFailure(call: Call&lt;List&lt;Book&gt;&gt;, t: Throwable) &#123;
            t.printStackTrace()
        &#125;
    &#125;)
&#125;</code></pre>
<ol>
<li>按照之前步骤配置 HTTP 明文请求 + AndroidManifest 中配置网络权限</li>
</ol>
<pre class="language-markup" data-language="markup"><code class="language-markup">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot; &#x2F;&gt;</code></pre>
<h2 id="复杂接口">复杂接口</h2>
<p>通过变量匹配多个接口</p>
<ul>
<li>Path 中应用变量</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">@GET(&quot;&#123;page&#125;&#x2F;get_data.json&quot;)
fun getData(@Path(&quot;page&quot;) page: Int): Call&lt;Data&gt;</code></pre>
<ul>
<li>GET 请求中的参数: <code>http://example.com/get_data.json?u=&lt;user&gt;&amp;t=&lt;token&gt;</code></li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">@GET(&quot;get_data.json&quot;)
fun getData(@Query(&quot;u&quot;) user: String, @Query(&quot;t&quot;) token: String): Call&lt;Data&gt;</code></pre>
<ul>
<li>POST 请求中的参数</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">@POST(&quot;data&#x2F;create.json&quot;)
fun createData(@Body data: Data): Call&lt;ResonseBody&gt;</code></pre>
<ul>
<li>静态配置请求头参数</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">@Headers(&quot;User-Agent: ...&quot;, &quot;Cache-Control: ...&quot;)
@GET(&quot;get_data.json&quot;)
fun getData(): Call&lt;Data&gt;</code></pre>
<ul>
<li>动态配置请求头参数</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">@GET(&quot;get_data.json&quot;)
fun getData(@Header(&quot;User-Agent&quot;) userAgent: String,
@Header(&quot;Cache-Control&quot;) cacheControl: String): Call&lt;Data&gt;</code></pre>
<h2 id="单例类封装">单例类封装</h2>
<p>Service 的动态代理对象是能通用的, 因此依旧可以通过创建一个单例类来实现共享使用</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">object ServiceCreator &#123;
    private const val BASE_URL &#x3D; &quot;http:&#x2F;&#x2F;10.0.2.2&#x2F;&quot;
    private val retrofit &#x3D; Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    fun &lt;T&gt; create(serviceClass: Class&lt;T&gt;): T &#x3D; retrofit.create(serviceClass)

    inline fun &lt;reified T&gt; create(): T &#x3D; create(T::class.java)
&#125;</code></pre></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://jiancongcui.github.io/2022/08/30/11-Web/,Jiancong Cui,11-Web,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/09/05/12-Material-Design/" title="12-Material Design">prev_post</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/08/23/10-Service/" title="10-Service">next_post</a></li></ul></div></div></div><div class="footer animated fadeInDown"><div class="p"> <span>© 2024 - 2029 </span><i class="fa fa-star"></i><span> JCC</span></div><div class="by_farbox"><span>Powered by </span><a href="https://sites.google.com/new" target="_blank">Google Sites </a><span> & </span><a href="https://github.com/Ben02/hexo-theme-Anatole" target="_blank">Ben </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core </a></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>