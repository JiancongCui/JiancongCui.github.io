<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="JCC"><title>13-Jetpack · Jiancong Cui</title><meta name="description" content="Jetpack
Jetpack 是一个开发组件工具集，它的主要目的是帮助我们编写出更加简洁的代码，并简化我们的开发过程
全家桶: 基础, 架构, 行为, 界面; 这里我们主要介绍 Jetpack 架构
MMVM
MMVM, Model-View-ViewModel, Model 是数据模型部分；Vi"><meta name="keywords" content="Computer Science, Privacy Security,"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&amp;display=swap"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/tag.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><link rel="shortcut icon" href="/images/jcc.webp"><script src="/js/jquery.js"></script><!-- 主题：可换 one-dark/tomorrow/github 等 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-themes@1.9.0/themes/prism-one-dark.css">
<!-- 行号 + 工具栏的样式 -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.css">
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/toolbar/prism-toolbar.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/show-language/prism-show-language.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="page-top animated fadeInDown"><div class="nav-container"> <div class="nav"><a class="nav-item logo" href="/">Jiancong Cui </a><a class="nav-item" href="/">About Me</a><a class="nav-item" href="/blogs">Posts</a><a class="nav-item" href="/archives">Archive</a><a class="nav-item" href="/tags">Tags</a><a class="nav-item" href="/quotes">Quotes</a></div></div></div><div id="main-container"><div class="main-content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><a>13-Jetpack</a></div><div class="post-labels"><div class="label-item"> <i class="fa fa-clock-o"></i><span class="date">2022-09-11</span></div><div class="label-item"> <i class="fa fa-list"></i><a class="tag" href="/categories/Android-Dev/" title="Android Dev.">Android Dev.</a></div><div class="label-item"><i class="fa fa-bookmark"></i><a class="tag" href="/tags/Android/" title="Android">Android</a></div><span class="leancloud_visitors"></span></div><div class="post-content"><h1>Jetpack</h1>
<p>Jetpack 是一个开发组件工具集，它的主要目的是帮助我们编写出更加简洁的代码，并简化我们的开发过程</p>
<p>全家桶: 基础, 架构, 行为, 界面; 这里我们主要介绍 Jetpack 架构</p>
<h1>MMVM</h1>
<p>MMVM, Model-View-ViewModel, Model 是数据模型部分；View 是界面展示部分；ViewModel 可以理解成一个连接数据模型和界面展示的桥梁，从而实现让业务逻辑和界面展示分离的程序结构设计</p>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202209121229074.png" alt=""></p>
<ul>
<li>UI 控制层: Activity, Fragment, 布局文件等与界面相关的东西</li>
<li>ViewModel: 层用于持有和 UI 元素相关的数据，以保证这些数据在屏幕旋转时不会丢失; 提供接口给 UI 控制层调用以及和仓库层进行通信</li>
<li>仓库: 判断调用方请求的数据应该是从本地数据源中获取还是从网络数据源中获取，并将获取到的数据返回给调用方
<ul>
<li>本地数据源: 数据库、SharedPreferences 等持久化技术</li>
<li>网络数据源: 使用 Retrofit 访问服务器提供的 Webservice 接口来实现</li>
</ul>
</li>
</ul>
<h1>ViewModel</h1>
<p>Motivation: 传统 Activity 既要负责逻辑处理又要负责 UI 展示, 甚至还得处理网络回调</p>
<p>ViewModel 是专门用于存放与界面相关的数据的</p>
<ul>
<li>手机发生横竖屏旋转时, Activity 会被重建, 但 ViewModel 声明周期与 Activity 不同, 因此数据也不会丢失</li>
<li>只有调用 <code>onCleared()</code> 方法 ViewModel 才会被销毁</li>
</ul>
<h2 id="Quick-Start">Quick Start</h2>
<ol>
<li>推荐给每一个 Activity 和 Fragment 都创建一个对应的 ViewModel, 里面存储用于展示的信息</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class MainViewModel: ViewModel() &#123;
    var counter &#x3D; 0
&#125;</code></pre>
<ol start="2">
<li>在对应的 Activity 或 Fragment 中创建对应的 viewModel 实例</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val viewModel by lazy &#123; ViewModelProvider(this).get(MainViewModel::class.java) &#125;</code></pre>
<ol start="3">
<li>逻辑操作</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val buttonPlus: Button &#x3D; findViewById(R.id.plusOneBtn)
buttonPlus.setOnClickListener &#123;
    viewModel.counter++
    refreshCounter()
&#125;</code></pre>
<h2 id="向-ViewModel-传递参数">向 ViewModel 传递参数</h2>
<p>比如让 ViewModel 加载的时候, 可以先在 Activity 中尝试读取本地缓存的数据信息, 然后将读取的内容传递给 ViewModel 进行数据维护</p>
<ol>
<li>需要创建一个 ViewModel 的工厂类, 重写其 create 方法, 使其适配参数传递</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class MainViewModelFactory(private val countReserved: Int): ViewModelProvider.Factory &#123;

    override fun &lt;T : ViewModel?&gt; create(modelClass: Class&lt;T&gt;): T &#123;
        return MainViewModel(countReserved) as T
    &#125;

&#125;</code></pre>
<ol start="2">
<li>使用工厂类实现 ViewModel 的实例化</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">viewModel &#x3D; ViewModelProvider(this, MainViewModelFactory(countReserved)).get(MainViewModel::class.java)</code></pre>
<h1>Lifecycles</h1>
<p>Motivation: 对 Activity 生命周期情况进行感知, 某个界面中发起了一条网络请求，但是当请求得到响应的时候，界面或许已经关闭了，这个时候就不应该继续对响应的结果进行处理。因此，我们需要能够时刻感知到Activity的生命周期，以便在适当的时候进行相应的逻辑控制。</p>
<p>Lifecycles 可以让任何一个类都能轻松感知到 Activity 的生命周期，同时又不需要在 Activity 中编写大量的逻辑处理</p>
<h2 id="Quick-Start-2">Quick Start</h2>
<ol>
<li>新建一个自己的 MyObserver 类，并让它实现 LifecycleObserver 接口（主要就是声明一下）</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyObserver: LifecycleObserver &#123;&#125;</code></pre>
<ol start="2">
<li>接口中根据相关注解定义感知 Activity 生命周期的逻辑处理方法</li>
</ol>
<p>声明周期事件类型: <code>ON_CREATE</code>, <code>ON_START</code>, <code>ON_RESUME</code>, <code>ON_PAUSE</code>, <code>ON_STOP</code>, <code>ON_DESTROY</code>; 特殊的有一种 <code>ON_ANY</code> 表示可以匹配 Activity 的任何生命周期回调</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyObserver : LifecycleObserver &#123;
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    fun activityStart() &#123;
        Log.d(&quot;MyObserver&quot;, &quot;activityStart&quot;)
    &#125;
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    fun activityStop() &#123;
        Log.d(&quot;MyObserver&quot;, &quot;activityStop&quot;)
    &#125;
&#125;</code></pre>
<ol start="3">
<li>获取 Activity 或 Fragment 本身的 LifecycleOwner 实例, 实现对 MyObserver 的通知</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">lifecycle.addObserver(MyObserver())</code></pre>
<h2 id="主动状态感知">主动状态感知</h2>
<p>在 Observer 中主动获知当前的生命周期状态</p>
<ol>
<li>构造 Observer 时需要将 Lifecycle 对象传递进来</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">class MyObserver(val lifecycle: Lifecycle) : LifecycleObserver &#123;
    ...
&#125;</code></pre>
<ol start="2">
<li>通过 lifecycler 对象获取当前 Activity 的状态</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">lifecycle.currentState
&#x2F;&#x2F; 返回的生命周期状态是一个枚举类型: INITIALIZED, DESTROYED, CREATED, STARTED, RESUMED</code></pre>
<p><img src="https://raw.githubusercontent.com/Coming98/pictures/main/202209051928800.png" alt=""></p>
<h1>LiveData</h1>
<p>Motivation: 对 ViewModel 进行写后读时, 在单线程模式没问题, 但是如果复杂写, 需要开启额外线程执行, 那么写后读, 读到的大概率还是旧数据</p>
<p>LiveData 是 Jetpack 提供的一种响应式编程组件，它可以包含任何类型的数据，并在数据发生变化的时候通知给观察者</p>
<ul>
<li>常与 ViewModel 结合使用</li>
<li>在子线程中给 LiveData 设置数据，要调用 postValue() 方法，而不能再使用 setValue() 方法</li>
</ul>
<h2 id="Quick-Start-3">Quick Start</h2>
<ol>
<li>使用相关的 LiveData 去维护相关变量</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">var counter &#x3D; MutableLiveData&lt;Int&gt;()</code></pre>
<ol start="2">
<li>初始化变量, 并书写变量相关的处理接口</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">init &#123;
    counter.value &#x3D; countReserved
&#125;

fun plusOne() &#123;
    val count &#x3D; counter.value ?: 0
    counter.value &#x3D; count + 1
&#125;

fun clear() &#123;
    counter.value &#x3D; 0
&#125;</code></pre>
<ol start="3">
<li>在 Activity 中书写相关逻辑处理, 并监听回调</li>
</ol>
<p>observe 方法接收两个参数：第一个参数是 LifecycleOwner 对象(Activity OR Fragment)；第二个参数是一个 Observer 接口，表示当 counter 中包含的数据发生变化时，就会回调到这里</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val buttonPlus: Button &#x3D; findViewById(R.id.plusOneBtn)
buttonPlus.setOnClickListener &#123;
    viewModel.plusOne()
&#125;

val buttonClean: Button &#x3D; findViewById(R.id.clearBtn)
buttonClean.setOnClickListener &#123;
    viewModel.clear()
&#125;

viewModel.counter.observe(this) &#123;
    count -&gt; textInfo.text &#x3D; count.toString()
&#125;</code></pre>
<h2 id="更好的封装性">更好的封装性</h2>
<p>Quick Start 中将 counter 这个可变的 LiveData 暴露给了外部，这样即使是在 ViewModel 的外面也是可以给 counter 设置数据的，从而破坏了 ViewModel 数据的封装性，同时也可能带来一定的风险</p>
<p>因此永远只暴露不可变的 LiveData 给外部，这样在非 ViewModel 中就只能观察 LiveData 的数据变化，而不能给 LiveData 设置数据</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">
class MainViewModel(countReserved: Int): ViewModel() &#123;

&#x2F;&#x2F;    var counter &#x3D; MutableLiveData&lt;Int&gt;()

    &#x2F;&#x2F; counter 变量, 类型为不可变的 LiveData, 重写 get 方法返回 _counter 变量
    &#x2F;&#x2F; 当外部调用 counter 变量时，实际上获得的就是 _counter 的实例（转型为 LiveData 类型），但是无法给 counter 设置数据，从而保证了 ViewModel 的数据封装性
    val counter: LiveData&lt;Int&gt;
        get() &#x3D; _counter

    &#x2F;&#x2F; private 修饰, 对外部不可见
    private val _counter &#x3D; MutableLiveData&lt;Int&gt;()
    init &#123;
        _counter.value &#x3D; countReserved
    &#125;

    fun plusOne() &#123;
        val count &#x3D; _counter.value ?: 0
        _counter.value &#x3D; count + 1
    &#125;

    fun clear() &#123;
        _counter.value &#x3D; 0
    &#125;
&#125;</code></pre>
<h2 id="map">map</h2>
<p>将实际包含数据的 LiveData 和仅用于观察数据的 LiveData 进行转换</p>
<p>Application: ViewModel 保存了一个用户数据类的实例, 但是界面展示时只会涉及到用户的名字, 不会涉及到其年龄, 身高, 因此将整个用户数据实例暴露给外部读取也十分危险, 需要进一步封装转换, 使其只暴露姓名</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private val userLiveData &#x3D; MutableLiveData&lt;User&gt;()
val username: LiveData&lt;String&gt; &#x3D; Transformations.map(userLiveData) &#123;
    user -&gt; &quot;$&#123;user.firstName&#125; $&#123;user.lastName&#125;&quot;
&#125;</code></pre>
<h2 id="switchMap">switchMap</h2>
<p>前面我们所学的所有内容都有一个前提：LiveData 对象的实例都是在 ViewModel 中创建的</p>
<p>然而在实际的项目中，不可能一直是这种理想情况，很有可能 ViewModel 中的某个 LiveData 对象是调用另外的方法获取的</p>
<h2 id="Quick-Start-4">Quick Start</h2>
<ol>
<li>通过数据库获取所有的 TodoItem</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">fun refreshTodoItemByCategory(todoCategoryId: Long) &#x3D; fire(Dispatchers.IO) &#123;
    if(todoCategoryId &#x3D;&#x3D; -1L) &#123;
        val todoItemList &#x3D; todoDatabase.todoItemDao().getAllTodoItem()
        Result.success(Pair(&quot;星海&quot;, todoItemList))
    &#125; else &#123;
        &#x2F;&#x2F; 获取类别名词 - 用于标题栏展示
        coroutineScope &#123;
            val todoCategory_ &#x3D; async &#123;
                todoDatabase.todoCategoryDao().getTodoCategoryById(todoCategoryId)
            &#125;
            val todoItemList_ &#x3D; async &#123;
                todoDatabase.todoItemDao().getTodoItemsByCategoryId(todoCategoryId)
            &#125;
            val todoCategoryName: String &#x3D; todoCategory_.await().name
            val todoItemList &#x3D; todoItemList_.await()
            Result.success(Pair(todoCategoryName, todoItemList))
        &#125;
    &#125;
&#125;
&#x2F;&#x2F; fire: 统一的入口函数中进行封装, 使得只要进行一次 try catch 处理就行了
&#x2F;&#x2F; 自动开启线程处理, 根据成功或失败返回相应的 Result 对象
private fun &lt;T&gt; fire(
    context: CoroutineContext,
    block: suspend () -&gt; Result&lt;T&gt;
) &#x3D; liveData&lt;Result&lt;T&gt;&gt;(context)&#123;
    val result &#x3D; try &#123;
        block()
    &#125; catch (e: Exception) &#123;
        Result.failure&lt;T&gt;(e)
    &#125;
    emit(result)
&#125;</code></pre>
<ol start="2">
<li>维护内部观察者, 触发数据库操作, 并返回 LiveData 对象</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 维护 TodoCategoryId, 如果其变化则触发数据库 refreshTodoItemByCategory 操作
private val refreshTodoItemByCategoryObs &#x3D; MutableLiveData&lt;Long&gt;()

val refreshTodoItemByCategoryResult &#x3D; Transformations.switchMap(refreshTodoItemByCategoryObs) &#123; todoCategoryId -&gt;
    &#x2F;&#x2F; 返回 Result 对象, 交由外部 refreshTodoItemByCategoryResult 的 Observer 进行处理
    Repository.refreshTodoItemByCategory(todoCategoryId)
&#125;

&#x2F;&#x2F; 提供给外部的事件调用接口, 使得监听数据产生变化, 进而触发数据库操作
fun refreshTodoItemByCategory(todoCategoryId: Long) &#123;
    refreshTodoItemByCategoryObs.value &#x3D; todoCategoryId
&#125;</code></pre>
<ol start="3">
<li>维护外部观察者, 对数据库返回的数据加工处理</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">viewModel.refreshTodoItemByCategoryResult.observe(this, Observer &#123; result -&gt;
    val pairResult &#x3D; result.getOrNull()
    if(pairResult !&#x3D; null) &#123;
        val todoCategoryName &#x3D; pairResult.first
        val todoItemList &#x3D; pairResult.second

        viewModel.todoItemList.clear()
        viewModel.todoItemList.addAll(todoItemList)
        adapter_todoitem.notifyDataSetChanged()

        toolbarFragment.refreshToolbarName(todoCategoryName, viewModel.todoCategoryId &#x3D;&#x3D; -1L)

        if(todoItemSwipeRefresh.isRefreshing) &#123;
            todoItemSwipeRefresh.isRefreshing &#x3D; false
        &#125;

        if(drawerLayout.isDrawerOpen(GravityCompat.START)) &#123;
            drawerLayout.closeDrawer(GravityCompat.START)
        &#125;
    &#125;
&#125;)</code></pre>
<p>Tips: 如果外部生成的 LiveData 实例没有相关属性可供监听, 那么只需要监听一个空属性即可</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">private val refreshLiveData &#x3D; MutableLiveData&lt;Any?&gt;()
val refreshResult &#x3D; Transformations.switchMap(refreshLiveData) &#123;
    Repository.refresh() &#x2F;&#x2F; 假设Repository中已经定义了refresh()方法
&#125;
&#x2F;&#x2F; LiveData 内部不会判断即将设置的数据和原有数据是否相同，只要调用了 setValue() 或 postValue() 方法，就一定会触发数据变化事件
fun refresh() &#123;
    refreshLiveData.value &#x3D; refreshLiveData.value
&#125;</code></pre>
<h1>ROOM</h1>
<p>ROOM 是为 Android 数据库设计的 ORM 框架, 是对 SQLite 的封装; Room provides an abstraction layer over SQLite to allow fluent database access while harnessing the full power of SQLite</p>
<ul>
<li>Object Relational Mapping, 将面向对象的语言和面向关系的数据库之间建立一种映射关系</li>
</ul>
<p>Overall Structure: Entity, Dao, Database</p>
<ul>
<li>Entity: 定义封装实际数据的实体类; 每个实体类在数据库中对应一张表，并且表中的列是根据实体类中的字段<strong>自动生成</strong>的</li>
<li>Dao: Dao 是数据访问对象的意思，在这里对数据库的各项操作进行封装; 实际编程时，逻辑层不需要和底层数据库打交道，直接和 Dao 层进行交互</li>
<li>Database: 用于定义数据库中的关键信息，包括数据库的版本号、包含哪些实体类以及提供 Dao 层的访问实例</li>
</ul>
<h2 id="Strength">Strength</h2>
<ul>
<li>用面向对象的思维来和数据库进行交互</li>
<li>Room 支持在编译时动态检查 SQL 语句语法</li>
<li>Compile-time verification of SQL queries. each @Query and @Entity is checked at the compile time</li>
<li></li>
</ul>
<h2 id="Quick-CRUD">Quick CRUD</h2>
<p>常用操作: Create, Read, Update, Delete<br>
常用注解:</p>
<ul>
<li>@Entity(foreignKeys, indices, primaryKeys, tableName)</li>
<li>@PrimaryKey(autoGenerate = true)</li>
<li>@ColumnInfo(name=“column_name”): allows specifying custom information about column</li>
<li>@Ignore: field will not be persisted by Room</li>
<li>@Embeded: nested fields can be referenced directly in the SQL queries</li>
</ul>
<ol>
<li>引入相关依赖</li>
</ol>
<ul>
<li>kotlin-kapt 插件: 引入 Room 编译时的注解库</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">apply plugin: &#39;com.android.application&#39;
apply plugin: &#39;kotlin-android&#39;
apply plugin: &#39;kotlin-android-extensions&#39;
apply plugin: &#39;kotlin-kapt&#39;

dependencies &#123;
    implementation &quot;androidx.room:room-runtime:2.1.0&quot;
    kapt &quot;androidx.room:room-compiler:2.1.0&quot;
&#125;</code></pre>
<ol start="2">
<li>编写相关实体类, 使用 ROOM 的注解完成面向对象</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 定义实体类的注解
@Entity
data class User(var firstName: String, var lastName: String, var age: Int) &#123;

    @PrimaryKey(autoGenerate &#x3D; true)
    var id: Long &#x3D; 0
&#125;</code></pre>
<ol start="3">
<li>编写相关的数据库操作接口, DAO</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">@Dao
interface UserDao &#123;

    &#x2F;&#x2F; 表示会将参数中传入的 User 对象插入数据库中，插入完成后还会将自动生成的主键 id 值返回
    @Insert
    fun insertUser(user: User): Long

    &#x2F;&#x2F; 会将参数中传入的 User 对象更新到数据库当中
    @Update
    fun updateUser(newUser: User)

    &#x2F;&#x2F; 会将参数传入的 User 对象从数据库中删除
    @Delete
    fun deleteUser(user: User)

    &#x2F;&#x2F; 查询或精细化的删除操作, 需要传入相关的 SQL 语言
    @Query(&quot;select * from User&quot;)
    fun findAllUsers(): List&lt;User&gt;

    @Query(&quot;select * from User where age &gt; :age&quot;)
    fun findUsersOlderThan(age: Int): List&lt;User&gt;

    @Query(&quot;delete from User where lastName &#x3D; :lastName&quot;)
    fun deleteUserByLastName(lastName: String): Int

&#125;</code></pre>
<ol start="4">
<li>定义 Database: 数据库的版本号、包含哪些实体类、提供 Dao 层的访问实例</li>
</ol>
<h1>WorkManager</h1>
<p>WorkManager 是一个处理定时任务的工具，可以保证即使在应用退出甚至手机重启的情况下，之前注册的任务仍然将会得到执行</p>
<ul>
<li>但是为了减少电量消耗，进行了一些优化，因此不能保证准时执行；比如将触发时间临近的几个任务放在一起执行，这样可以大幅度地减少 CPU 被唤醒的次数，从而有效延长电池的使用时间</li>
</ul>
<h2 id="Quick-Start-5">Quick Start</h2>
<ol>
<li>添加相关依赖: <code>implementation &quot;androidx.work:work-runtime:2.7.1&quot;</code></li>
<li>定义一个后台任务，并实现具体的任务逻辑</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 不会运行在主线程
override fun doWork(): Result &#123;
    Log.d(&quot;SimpleWorker&quot;, &quot;do work in jcworker&quot;)
    return Result.success() &#x2F;&#x2F; Result.failure() OR Result.retry()
&#125;</code></pre>
<ol start="3">
<li>配置该后台任务的运行条件和约束信息，并构建后台任务请求</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; Example &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
val request &#x3D; OneTimeWorkRequest.Builder(SimpleWorker::class.java).build() &#x2F;&#x2F; basic
val request &#x3D; PeriodicWorkRequest.Builder(SimpleWorker::class.java, 15, TimeUnit.MINUTES).build() &#x2F;&#x2F; Periodic
&#x2F;&#x2F; Basic &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;
&#x2F;&#x2F;&#x2F;&#x2F; 后台任务的具体运行时间是由我们所指定的约束以及系统自身的一些优化所决定
&#x2F;&#x2F;&#x2F;&#x2F; 由于这里没有指定任何约束，因此后台任务基本上会在点击按钮之后立刻运行
val request &#x3D; OneTimeWorkRequest.Builder(JCWorker::class.java).build()
WorkManager.getInstance(this).enqueue(request)</code></pre>
<ol start="4">
<li>将该后台任务请求传入 WorkManager 的 enqueue() 方法中，系统会在合适的时间运行</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">WorkManager.getInstance(context).enqueue(request) &#x2F;&#x2F; basic</code></pre>
<h2 id="延时任务">延时任务</h2>
<p>构建后台任务请求时借助 <code>setInitialalDelay()</code> 方法让后台任务延时执行</p>
<ul>
<li>单位: TimeUnit.SECONDS, MINUTES, HOURS, DAYS, MICROSECONDS, MILLISECONDS, NANOSECONDS</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 推迟 5s 执行
val request &#x3D; OneTimeWorkRequest.Builder(JCWorker::class.java)
    .setInitialDelay(5, TimeUnit.SECONDS)
    .build()</code></pre>
<h2 id="取消后台任务">取消后台任务</h2>
<ol>
<li>可以在后台任务构建时指定该任务的标签, 多个任务可以绑定相同标签, 从而进行统一控制</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val request &#x3D; OneTimeWorkRequest.Builder(JCWorker::class.java)
    .setInitialDelay(5, TimeUnit.SECONDS)
    .addTag(&quot;JCWork&quot;)
    .build()</code></pre>
<ol start="2">
<li>使用 WorkManager 的实例方法进行取消</li>
</ol>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">WorkManager.getInstance(this).cancelAllWorkByTag(&quot;JCWork&quot;)
&#x2F;&#x2F; 或者使用 id 取消
WorkManager.getInstance(this).cancelWorkById(request.id)</code></pre>
<h2 id="任务执行状态的监听">任务执行状态的监听</h2>
<h3 id="Result-retry">Result.retry()</h3>
<p>如果在复现的 <code>doWork()</code> 方法中返回了 <code>Result.retry()</code> 那么可以提前通过 <code>setBackoffCriteria()</code> 方法配置好任务的重启配置</p>
<p>Tips: 如果任务一直执行失败, 那么一直重试没有意义, 因此应让重试间隔随着重试次数的增加而增加</p>
<ul>
<li>BackoffPolicy.LINEAR: 代表下次重试时间以线性的方式延迟</li>
<li>BackoffPolicy.EXPONENTIAL 代表下次重试时间以指数的方式延迟</li>
</ul>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 第一个参数则用于指定如果任务再次执行失败，下次重试的时间应该以什么样的形式延迟
&#x2F;&#x2F; 第二, 三个参数用于指定在多久之后重新执行任务，时间最短不能少于 10 秒钟
val request &#x3D; OneTimeWorkRequest.Builder(JCWorker::class.java)
    .setInitialDelay(5, TimeUnit.SECONDS)
    .addTag(&quot;JCWork&quot;)
    .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.SECONDS)
    .build()</code></pre>
<h3 id="SUCCEEDED-OR-FAILED">SUCCEEDED OR FAILED</h3>
<p>成功或失败的执行状态需要通过对 WorkManager 的配置进行响应</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">&#x2F;&#x2F; 返回一个 LiveData 对象, 用这个维护任务的状态
WorkManager.getInstance(this).getWorkInfoByIdLiveData(request.id)
    .observe(this) &#123; workInfo -&gt;
    if (workInfo.state &#x3D;&#x3D; WorkInfo.State.SUCCEEDED) &#123;
        Log.d(&quot;SimpleWorker&quot;, &quot;Succeeded&quot;)
    &#125; else if (workInfo.state &#x3D;&#x3D; WorkInfo.State.FAILED) &#123;
        Log.d(&quot;SimpleWorker&quot;, &quot;FAILED&quot;)
    &#125;
&#125;</code></pre>
<h2 id="链式任务">链式任务</h2>
<p>定义了多个独立的任务且具有先后顺序的情况, 使用链式任务进行先后执行</p>
<p>Tips: 必须在前一个后台任务运行成功之后，下一个后台任务才会运行。也就是说，如果某个后台任务运行失败，或者被取消了，那么接下来的后台任务就都得不到运行了</p>
<pre class="language-kotlin" data-language="kotlin"><code class="language-kotlin">val sync &#x3D; ... &#x2F;&#x2F; 同步数据任务
val compress &#x3D; ... &#x2F;&#x2F; 压缩数据任务
val upload &#x3D; ... &#x2F;&#x2F; 上传数据任务
WorkManager.getInstance(this)
    .beginWith(sync)
    .then(compress)
    .then(upload)
    .enqueue()</code></pre>
<h2 id="额外注意">额外注意</h2>
<p>前面所介绍的 WorkManager 的所有功能，在国产手机上都有可能得不到正确的运行</p>
<p>绝大多数的国产手机厂商在进行 Android 系统定制的时候会增加一个一键关闭的功能，允许用户一键杀死所有非白名单的应用程序。而被杀死的应用程序既无法接收广播，也无法运行 WorkManager 的后台任务</p>
<p>因此 WorkManager 可以用，但是千万别依赖它去实现什么核心功能，因为它在国产手机上可能会非常不稳定</p>
</div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://jiancongcui.github.io/2022/09/11/13-Jetpack/,Jiancong Cui,13-Jetpack,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/11/11/01-llvm-basic/" title="01-llvm-basic">prev_post</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/09/05/12-Material-Design/" title="12-Material Design">next_post</a></li></ul></div></div></div><div class="footer animated fadeInDown"><div class="p"> <span>© 2024 - 2029 </span><i class="fa fa-star"></i><span> JCC</span></div><div class="by_farbox"><span>Powered by </span><a href="https://sites.google.com/new" target="_blank">Google Sites </a><span> & </span><a href="https://github.com/Ben02/hexo-theme-Anatole" target="_blank">Ben </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core </a></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>